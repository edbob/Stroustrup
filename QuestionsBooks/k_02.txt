Задание 2: 

Контрольные вопросы
1 . Что подразумевается под приглашением?
    Первая строка функции main() cout << "Please enter first name: "; просто выводит на экран сообщение,
    предлагающее пользователю ввести свое имя. Такое сообщение называется
    приглашением. поскольку предлагает пользователю предпринять какое-
    то действие.

2. Какой оператор используется для чтения в переменную?
    Имя cin обращается к стандартному потоку ввода (читается как "си-ин"
    и является аббревиатурой от character input) , определенному в стандартной
    библиотеке. Второй операнд оператора >> ("получить из") определяет
    участок памяти , в который производится ввод.

3. Если вы хотите, чтобы пользователь ввел целое значение в переменную
с именем number, какие две строки следует добавить в программу,
чтобы предложить пользователю ввести значение в вашу программу и
считать введенное им значение?
    
4. Как называется символ \n и для чего он предназначен?
    это "специальный символ", означающий переход на новую строку.

5. Что прекращает ввод значения в строку?

    Комбинация клавиш <ctrl+Z> Enter! В Unix <ctrl+D>
6. Что прекращает ввод значения в целочисленную переменную?
    пробел, табуляция, перевод строки!

7. Как записать одной строкой следующий код?
    cout « "Привет."
    cout « first_name ;
    cout « " ! \n " ;

    cout << "Привет" << first_name << "!\n"; 

8. Что такое объект?
    • объект- участок памяти, в котором хранится значение определенного типа.
    • Тип определяет набор возможных значений и операций, выполняемых над объектом.
    • Значение - набор битов в памяти, интерпретируемый в соответствии с типом.
    • Переменная - именованный объект.
    • Объявление - инструкция, приписывающая объекту определенное имя.
    • Определение - объявление, выделяется память для объекта
    
9 . Что такое литерал?
    Это элемент программы, который непосредственно представляет значение.
    Обозначение, которое непосредственно задает число, например
    литерал 1 2 задает целое число, равное "двенадцать".

1 0. Какие виды литералов существуют?
     in, double, string, bool, символьные литералы, указательные 

1 1 . Что такое переменная?
     Именованный объект.

1 2 . Каковы типичные размеры переменных типов char, int и double?
    int  4 байта(32 бита), bool char 1 байт(8 бит), double 8 байт!

1 3 . В каких единицах измеряется объем памяти, занимаемой небольшими переменными, например объектами типов int и string?
    В битах, Бит - это единица памяти компьютера, которая может
    хранить только либо 0. либо 1. В in 4 байта а string - что разные строки могут занимать разное количество памяти.

1 4. В чем заключается разница между операторами = и =?
    в случае (=) это Инициализация и присваивание!
    в (==) оператор сравнения если значения равны возвращает true!

1 5. Что такое определение?
    Объявление сущности , содержащее всю необходимую
    информацию для его использования в программе. Упрощенное
    определение: объявление. выделяющее память

1 6. Что такое инициализация и чем она отличается от присваивания?
    Инициализация выглядит так int x=10;
    Присваивания y=9;
1 7 . Что такое конкатенация строк и как она выполняется в языке С++?
    Склеивание строк: Выбирай string, конкатенация делается так str3 = str1 + str2.

1 8 . Какие из приведенных далее имен являются допустимыми в языке

С++? Если имя является недопустимым, укажите, по какой причине.
Тhiв_littl_peyig
lateвt thing- переменная с пробелом не допустима
МiniМineмine
Тhiв 1 iв fine
the_$ 12_шethod- не желательно использовать спецальные символы
nuшber 
2_For_l_вpecial- непонятно для чего такая переменная
thiв in ok- что ок тоже не понято
correct?

1 9. Приведите пять примеров корректных имен. которые вы не стали бы
использовать, чтобы не создавать недоразумений.
    ш.tЬf
    TLA
    шуw
    NВV

20. Сформулируйте разумные правила для выбора имен.
    Должны быть простыми и понятными без специальных символов
    partial_swn
    element count
    staЬleyartition
    слишком длинные именованны
    the nuшЬer of eleшents
    reшaininq_free_slots_in_symЬol_taЫe

2 1 . Что такое безопасность типов и почему она так важна?
    douЫe в int
    douЫe в char
    douЫe в Ьооl
    int в char
    int в bool
    char в bool
    Эти преобразования являются опасными в том смысле, что значение,
    хранящееся в переменной, может отличаться от присвоенного
    . Почему эта ситуация считается проблемой? Потому что зача-
    стую вы и не подозреваете о том, что такое преобразование имело место .
    Рассмотрим пример.
    douЬle х • 2 . 7 ;
    / / Ка кой-то код
    int у • х ; // Зна чение переменной у становится равным 2
    К моменту определения переменной у вы уже могли забыть, что переменная
    х имеет тип douhle, или упустить из виду, что преобразование douЫe
    в int приводит к усечению (округлению по направлению к нулю) . Результат
    вполне предсказуем: семь десятых потеряны.
    Э. 9. Безопасность типов 1 23
    Преобразование int в char не порождает проблем с усечением - ни тип
    int, ни тип char не могут представить дробную часть целого числа. Однако
    переменная типа char может хранить только очень небольшие целочисленные
    значения. В персональных компьютерах переменная типа char занимает
    1 байт. в то время как переменная типа int - 4 байта.

22. Почему преобразование типа double в тип int может привести к
неприятностям?
    мы не можем записать большое число, например
    1 ООО. в переменную типа char без потери информации: значение
    "сужается". Рассмотрим пример.
    int а = 1000 ;
    char Ь = а ; // Зна чение Ь становится ра вным -24

23. Сформулируйте правило, помогающее решить, безопасно ли то или
иное преобразование типов.
    В С++ 11 вводится запись инициализации . которая запрещает сужающие
    преобразования. Например. мы можем (и должны) переписать приведенные
    выше проблемные примеры с использованием записи со списками
    в фигурных скобках вместо записи со знаком присваивания:
        double х { 2.7} ; // О!:\.
        int у { х } ; // Ошибка : double -> i n t может быть сужающим
        int а { 1000 } ; // ок
        char Ь { а } ; // Ошибка : i n t -> char может быть 
    Когда инициализатор представляет собой целочисленный литерал .
    компилятор в состоянии проверить его фактическое значение и принять
    значения, не вызывающие сужения :
    char b { 1000 } ; / / Ошибка: сужение (в предположении
    // В - битового типа cha r)
    char b2 { 4 8 } ; // ОК

